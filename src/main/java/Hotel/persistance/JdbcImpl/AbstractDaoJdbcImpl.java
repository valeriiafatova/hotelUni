package Hotel.persistance.JdbcImpl;

import Hotel.persistance.Connection.DaoFactory;
import Hotel.persistance.DaoInterfaces.AbstractDao;
import Hotel.persistance.MapFunction.Mapper;
import Hotel.persistance.MapFunction.PrepareStatementFunc;
import Hotel.persistance.MapFunction.UserMapper;
import org.apache.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * Created by lerafatova on 27.04.17.
 */
public abstract class AbstractDaoJdbcImpl<T> implements AbstractDao<T> {
    private static final Logger LOGGER = Logger.getLogger(AbstractDaoJdbcImpl.class);
    protected DaoFactory daoFactory;

    public AbstractDaoJdbcImpl(DaoFactory daoFactory) {
        this.daoFactory = daoFactory;
    }

    protected int create(String sqlQuery, PrepareStatementFunc psFunc) {
        int autoGeneratedID = 0;
        try (Connection connection = daoFactory.getConnection();
             PreparedStatement statement = connection.prepareStatement(sqlQuery, Statement.RETURN_GENERATED_KEYS)) {
            psFunc.prepare(statement);
            statement.executeUpdate();
            ResultSet tableKeys = statement.getGeneratedKeys();
            tableKeys.next();
            autoGeneratedID = tableKeys.getInt(1);
        } catch (SQLException e) {
            LOGGER.error(e.getMessage());
            e.printStackTrace();
        }
        return autoGeneratedID;
    }

    protected <T> T find(String sql, PrepareStatementFunc psfunc, Mapper<T> func) {
        ResultSet resultSet = null;
        try (Connection connection = daoFactory.getConnection();
             PreparedStatement statement = connection.prepareStatement(sql)) {
            psfunc.prepare(statement);
            resultSet = statement.executeQuery();
            if (resultSet.next())
                return func.parse(resultSet);
            return null;
        } catch (SQLException e) {
            LOGGER.error(e.getMessage());
            e.printStackTrace();
        }
        return null;
    }

    public boolean update(String sqlQuery, PrepareStatementFunc psFunc) {
        int resultValue = 0;
        try (Connection connection = daoFactory.getConnection();
             PreparedStatement statement = connection.prepareStatement(sqlQuery)) {
            psFunc.prepare(statement);
            resultValue = statement.executeUpdate();
        } catch (SQLException e) {
            LOGGER.error(e.getMessage());
            e.printStackTrace();
        }
        return resultValue == 1 ? true : false;
    }

    protected boolean delete(String sql, PrepareStatementFunc psfunc) {
        try (Connection connection = daoFactory.getConnection();
             PreparedStatement statement = connection.prepareStatement(sql)) {
            psfunc.prepare(statement);
            int b = statement.executeUpdate();
            return b == 1 ? true : false;
        } catch (SQLException e) {
            LOGGER.error(e.getMessage());
            e.printStackTrace();
        }
        return false;
    }

    protected List<T> findAll(String sqlQuery, Mapper<T> func) {
        ResultSet resultSet = null;
        List<T> list = new ArrayList<>();
        try (Connection connection = daoFactory.getConnection();
             Statement statement = connection.createStatement()) {
            resultSet = statement.executeQuery(sqlQuery);
            while (resultSet != null && resultSet.next())
                list.add(func.parse(resultSet));
        } catch (SQLException e) {
            LOGGER.error(e.getMessage());
            e.printStackTrace();
        }
        return list;
    }

    protected List<T> findAll(String sql, PrepareStatementFunc psfunc, Mapper<T> func) {
        ResultSet resultSet = null;
        List<T> list = new ArrayList<>();
        try (Connection connection = daoFactory.getConnection();
             PreparedStatement statement = connection.prepareStatement(sql)) {
            psfunc.prepare(statement);
            resultSet = statement.executeQuery();
            while (resultSet != null && resultSet.next())
                list.add(func.parse(resultSet));
        } catch (SQLException e) {
            LOGGER.error(e.getMessage());
            e.printStackTrace();
        }
        return list;
    }
}
